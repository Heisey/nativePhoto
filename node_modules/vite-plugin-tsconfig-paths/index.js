"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/plugin.ts
var import_node_fs = __toESM(require("fs"));
var import_node_path = __toESM(require("path"));
var import_typescript = __toESM(require("typescript"));
var import_typescript_paths = require("typescript-paths");
var PLUGIN_NAME = "tsconfig-paths";
function tsConfigPaths({
  tsConfigPath,
  respectCoreModule,
  logLevel,
  colors = true
} = {}) {
  const log = (0, import_typescript_paths.createLogger)({ logLevel: (0, import_typescript_paths.convertLogLevel)(logLevel), colors, ID: PLUGIN_NAME });
  log(import_typescript_paths.LogLevel.Debug, `typescript version: ${import_typescript.default.version}`);
  let handler;
  let root = "";
  return {
    name: PLUGIN_NAME,
    enforce: "pre",
    configResolved(config) {
      root = config.root;
      log(import_typescript_paths.LogLevel.Debug, "build path mappings");
      handler = (0, import_typescript_paths.createHandler)({
        log,
        tsConfigPath,
        respectCoreModule,
        searchPath: root,
        falllback: (moduleName) => import_node_fs.default.existsSync(moduleName)
      });
    },
    handleHotUpdate(ctx) {
      if (ctx.file.endsWith(".json")) {
        log(import_typescript_paths.LogLevel.Debug, "build path mappings");
        handler = (0, import_typescript_paths.createHandler)({
          log,
          tsConfigPath,
          respectCoreModule,
          searchPath: root,
          falllback: (moduleName) => import_node_fs.default.existsSync(moduleName)
        });
      }
    },
    configureServer(server) {
      function handleChange() {
        log(import_typescript_paths.LogLevel.Debug, "build path mappings");
        handler = (0, import_typescript_paths.createHandler)({
          log,
          tsConfigPath,
          respectCoreModule,
          searchPath: root,
          falllback: (moduleName) => import_node_fs.default.existsSync(moduleName)
        });
      }
      server.watcher.on("add", handleChange);
      server.watcher.on("unlink", handleChange);
    },
    resolveId(request, importer, options) {
      if (!importer || request.startsWith("\0")) {
        return null;
      }
      let suffix = "";
      const m = request.match(/\?.+$/);
      if (m) {
        suffix = m[0];
        request = request.slice(0, m.index);
      }
      const moduleName = handler == null ? void 0 : handler(request, import_node_path.default.normalize(importer));
      if (!moduleName) {
        return this.resolve(request + suffix, importer, {
          skipSelf: true,
          ...options
        });
      }
      log(import_typescript_paths.LogLevel.Debug, `${request} -> ${moduleName}`);
      return moduleName + suffix;
    }
  };
}

// src/index.ts
tsConfigPaths["default"] = tsConfigPaths;
module.exports = tsConfigPaths;
